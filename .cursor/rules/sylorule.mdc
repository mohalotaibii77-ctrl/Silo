---
alwaysApply: true
---
## Architecture Principles: Backend as the Engine

### Core Principle
**The backend is the single engine that powers ALL frontends.** Every piece of business logic, data processing, calculation, validation, and transformation MUST happen in the backend. Frontends are purely visual interfaces that display what the backend provides.

### Backend Responsibilities (ALL business logic lives here)
- **ALL calculations** - margins, costs, totals, taxes, discounts, commissions, conversions, aggregations
- **ALL data processing** - filtering, sorting, grouping, transformations, formatting business data
- **ALL validations** - business rules, constraints, permissions, data integrity
- **ALL business rules** - pricing logic, inventory rules, order workflows, approval processes
- **ALL derived/computed values** - anything that requires logic to determine its value
- **Data warehouse, audit logs, and AI models**

If it involves logic beyond simple display formatting, it belongs in the backend.

### Frontend Responsibilities (UI layer ONLY)
- **Display** data exactly as received from backend APIs
- **Collect** user input and send raw values to backend
- **Navigate** between screens and routes
- **Style** the interface (colors, layouts, animations)
- **Format for display** - date formatting, number formatting for locale (not business calculations)

Frontends do NOT process, calculate, derive, aggregate, or transform business data.

### The Only Exception: Form Preview for UX
Frontends MAY show preview calculations while user fills a form for better UX experience.
- **MUST** include comment: `// UI preview only - backend calculates actual value on save`
- **MUST** send raw form data to backend
- **MUST** use backend-returned values after save
- Preview is for user feedback only, never for business decisions

### Implementation Pattern

// ❌ NEVER DO THIS - Frontend processing data
const totalRevenue = orders.reduce((sum, o) => sum + o.amount, 0);
const margin = ((price - cost) / price) * 100;
const filteredItems = items.filter(i => i.status === 'active' && i.stock > 0);

// ✅ ALWAYS DO THIS - Frontend displays backend values
const totalRevenue = dashboardData.total_revenue;  // Backend calculated
const margin = product.margin_percent;              // Backend calculated
const activeItems = await api.get('/items?status=active&in_stock=true'); // Backend filtered### When Adding New Features
1. Ask: "Does this involve any logic, calculation, or data processing?"
2. If YES → Implement in backend, return result via API
3. If NO (pure UI) → Implement in frontend
4. When in doubt → Put it in backend

### Project Scope
This APP solely uses the project **Silo** from our database. Don't edit or do anything to other projects.

When asked to implement something:
1. Implement following these architecture principles
2. Provide a brief summary in chat
3. Do not create documentation files unless explicitly requested

### Backend Architecture
The backend is a **Modular Monolith** containing all microservices:
- POS, Inventory, HR, Accounting, Operations, QHSE, Maintenance, Training, Customer Care, AI Core, or any features we will add later.
- Controls all business logic and Data proccesing to be the single source of truth that serves all frontends for unity.
- Serves as the single source of truth for all three frontends (SuperAdmin, Business App, Main)


## API Testing Requirement

### Core Principle
**Every API endpoint MUST have a corresponding test.** When implementing or modifying any backend API endpoint, the test script must be updated in the same session.

### Test Structure
Tests are organized by module in `backend/tests/`:

| Test File | Routes Covered | Description |
|-----------|----------------|-------------|
| `inventory.test.ts` | `inventory.routes.ts`, `inventory-stock.routes.ts`, `inventory-production.routes.ts`, `inventory-transaction.routes.ts` | Items, composite items, stock, vendors, PO, transfers, counts, movements, production, barcodes, timeline |
| `products.test.ts` | `store-products.routes.ts`, `categories.routes.ts`, `bundles.routes.ts`, `discounts.routes.ts` | Products CRUD, categories, bundles, discount codes |
| `pos.test.ts` | `pos.routes.ts`, `pos-session.routes.ts` | Orders, kitchen display, sessions, payments, delivery app orders |
| `users.test.ts` | `business-users.routes.ts` | Business users CRUD, permissions, password reset (owner-only) |
| `business.test.ts` | `business-settings.routes.ts`, `analytics.routes.ts`, `images.routes.ts` | Settings, localization, receipt, change requests, analytics, images |
| `delivery.test.ts` | `delivery.routes.ts`, `drivers.routes.ts`, `customers.routes.ts`, `tables.routes.ts` | Delivery partners, drivers, customers, restaurant tables |
| `config.test.ts` | `config.routes.ts`, `index.ts` | System config, units, currencies, roles (no auth required) |

### Route-to-Test Mapping
When creating/editing a route file, update the corresponding test:

```
src/api/inventory.routes.ts        → tests/inventory.test.ts
src/api/inventory-stock.routes.ts  → tests/inventory.test.ts
src/api/inventory-production.routes.ts → tests/inventory.test.ts
src/api/inventory-transaction.routes.ts → tests/inventory.test.ts
src/api/store-products.routes.ts   → tests/products.test.ts
src/api/categories.routes.ts       → tests/products.test.ts
src/api/bundles.routes.ts          → tests/products.test.ts
src/api/discounts.routes.ts        → tests/products.test.ts
src/api/pos.routes.ts              → tests/pos.test.ts
src/api/pos-session.routes.ts      → tests/pos.test.ts
src/api/business-users.routes.ts   → tests/users.test.ts
src/api/business-settings.routes.ts → tests/business.test.ts
src/api/analytics.routes.ts        → tests/business.test.ts
src/api/images.routes.ts           → tests/business.test.ts
src/api/delivery.routes.ts         → tests/delivery.test.ts
src/api/drivers.routes.ts          → tests/delivery.test.ts
src/api/customers.routes.ts        → tests/delivery.test.ts
src/api/tables.routes.ts           → tests/delivery.test.ts
src/api/config.routes.ts           → tests/config.test.ts
```

### When Adding/Modifying API Endpoints
1. **Identify** which test file covers the route (see mapping above)
2. **Implement** the endpoint in `src/api/*.routes.ts`
3. **Add test** to the corresponding test file immediately
4. **Run test** to verify: `npm run test:<module>`

### Test Pattern Template
```typescript
// For each endpoint, test:
// 1. Success case (happy path)
// 2. Validation errors (400)
// 3. Not found cases (404) if applicable
// 4. Authorization (401/403) if applicable

// Example for a new endpoint:
const result = await apiRequest(ctx, 'METHOD', '/api/path', body);
track(assertSuccess(result, 'METHOD /api/path - Description'));

// Example for validation test:
const invalid = await apiRequest(ctx, 'POST', '/api/path', { /* invalid data */ });
track(assertStatus(invalid, 400, 'POST /api/path - Validation (missing field)'));
```

### Package.json Scripts
```json
{
  "test:inventory": "npx ts-node tests/inventory.test.ts",
  "test:products": "npx ts-node tests/products.test.ts",
  "test:pos": "npx ts-node tests/pos.test.ts",
  "test:users": "npx ts-node tests/users.test.ts",
  "test:business": "npx ts-node tests/business.test.ts",
  "test:delivery": "npx ts-node tests/delivery.test.ts",
  "test:config": "npx ts-node tests/config.test.ts",
  "test:all": "npm run test:inventory && npm run test:products && npm run test:pos && npm run test:users && npm run test:business && npm run test:delivery && npm run test:config"
}
```

### Checklist Before Completing Any API Work
- [ ] Endpoint implemented in `src/api/*.routes.ts`
- [ ] Test added to correct `tests/*.test.ts` file (see mapping)
- [ ] Test includes: success case, validation (400), not found (404) if applicable
- [ ] Test passes locally: `npm run test:<module>`
- [ ] Related endpoints also tested if affected

### Never
- ❌ Create an endpoint without a test
- ❌ Modify an endpoint without updating its test
- ❌ Delete an endpoint without removing its test
- ❌ Mark API work as complete until tests pass
- ❌ Add test to wrong test file (always check the mapping)