---
alwaysApply: true
---
## Architecture Principles: Backend as the Engine

### Core Principle
**The backend is the single engine that powers ALL frontends.** Every piece of business logic, data processing, calculation, validation, and transformation MUST happen in the backend. Frontends are purely visual interfaces that display what the backend provides.

### Backend Responsibilities (ALL business logic lives here)
- **ALL calculations** - margins, costs, totals, taxes, discounts, commissions, conversions, aggregations
- **ALL data processing** - filtering, sorting, grouping, transformations, formatting business data
- **ALL validations** - business rules, constraints, permissions, data integrity
- **ALL business rules** - pricing logic, inventory rules, order workflows, approval processes
- **ALL derived/computed values** - anything that requires logic to determine its value
- **Data warehouse, audit logs, and AI models**

If it involves logic beyond simple display formatting, it belongs in the backend.

### Frontend Responsibilities (UI layer ONLY)
- **Display** data exactly as received from backend APIs
- **Collect** user input and send raw values to backend
- **Navigate** between screens and routes
- **Style** the interface (colors, layouts, animations)
- **Format for display** - date formatting, number formatting for locale (not business calculations)

Frontends do NOT process, calculate, derive, aggregate, or transform business data.

### The Only Exception: Form Preview for UX
Frontends MAY show preview calculations while user fills a form for better UX experience.
- **MUST** include comment: `// UI preview only - backend calculates actual value on save`
- **MUST** send raw form data to backend
- **MUST** use backend-returned values after save
- Preview is for user feedback only, never for business decisions

### Implementation Pattern

// ❌ NEVER DO THIS - Frontend processing data
const totalRevenue = orders.reduce((sum, o) => sum + o.amount, 0);
const margin = ((price - cost) / price) * 100;
const filteredItems = items.filter(i => i.status === 'active' && i.stock > 0);

// ✅ ALWAYS DO THIS - Frontend displays backend values
const totalRevenue = dashboardData.total_revenue;  // Backend calculated
const margin = product.margin_percent;              // Backend calculated
const activeItems = await api.get('/items?status=active&in_stock=true'); // Backend filtered### When Adding New Features
1. Ask: "Does this involve any logic, calculation, or data processing?"
2. If YES → Implement in backend, return result via API
3. If NO (pure UI) → Implement in frontend
4. When in doubt → Put it in backend

### Project Scope
This APP solely uses the project **Silo** from our database. Don't edit or do anything to other projects.

When asked to implement something:
1. Implement following these architecture principles
2. Provide a brief summary in chat
3. Do not create documentation files unless explicitly requested

### Backend Architecture
The backend is a **Modular Monolith** containing all microservices:
- POS, Inventory, HR, Accounting, Operations, QHSE, Maintenance, Training, Customer Care, AI Core, or any features we will add later.
- Controls all business logic and Data proccesing to be the single source of truth that serves all frontends for unity.
- Serves as the single source of truth for all three frontends (SuperAdmin, Business App, Main)


## API Testing Requirement

### Core Principle
**Every API endpoint MUST have a corresponding test.** When implementing or modifying any backend API endpoint, the test script must be updated in the same commit/session.

### Test Structure
Tests are organized by module in `backend/tests/`:
- `inventory.test.ts` - Inventory items, stock, vendors, PO, transfers, production
- `products.test.ts` - Products, categories, bundles, discounts, recipes
- `pos.test.ts` - Orders, payments, kitchen display, tables, sessions
- `users.test.ts` - Business users, owners, permissions
- `business.test.ts` - Business settings, branches, analytics
- `delivery.test.ts` - Delivery partners, drivers, customers
- `config.test.ts` - System configuration, images

### When Adding/Modifying API Endpoints
1. **Implement** the endpoint in the appropriate routes file
2. **Add test** to the corresponding test file immediately
3. **Run test** to verify: `npm run test:<module>`

### Test Pattern Template
// For each endpoint, test:
// 1. Success case (happy path)
// 2. Validation errors (400)
// 3. Not found cases (404) if applicable
// 4. Authorization (401/403) if applicable

// Example for a new endpoint:
const result = await apiRequest(ctx, 'METHOD', '/api/path', body);
track(assertSuccess(result, 'METHOD /api/path - Description'));### Package.json Scripts
{
  "test:inventory": "npx ts-node tests/inventory.test.ts",
  "test:products": "npx ts-node tests/products.test.ts",
  "test:pos": "npx ts-node tests/pos.test.ts",
  "test:users": "npx ts-node tests/users.test.ts",
  "test:business": "npx ts-node tests/business.test.ts",
  "test:delivery": "npx ts-node tests/delivery.test.ts",
  "test:config": "npx ts-node tests/config.test.ts",
  "test:all": "npm run test:inventory && npm run test:products && npm run test:pos && npm run test:users && npm run test:business && npm run test:delivery && npm run test:config"
}### Checklist Before Completing Any API Work
- [ ] Endpoint implemented in `src/api/*.routes.ts`
- [ ] Test added to `tests/*.test.ts`
- [ ] Test passes locally
- [ ] Related endpoints also tested if affected

### Never
- ❌ Create an endpoint without a test
- ❌ Modify an endpoint without updating its test
- ❌ Delete an endpoint without removing its test
- ❌ Mark API work as complete until tests pass